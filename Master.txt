		;====================================================================
		; Main.asm file generated by New Project wizard
		;
		; Created:   Thu Feb 1 2024
		; Processor: PIC16F877A
		; Compiler:  MPASM (Proteus)
		;====================================================================
		
		;====================================================================
		; DEFINITIONS
		;====================================================================
		
		#include p16f877a.inc                ; Include register definition file
		
		;====================================================================
		; VARIABLES
		;====================================================================
		TensOne EQU 0X20 
		UnitsOne EQU 0X21
		TensTwo EQU 0x22
		UnitsTwo EQU 0x23
		
		NumberOne EQU 0x24 ;; TensOne*10+UnitsOne (Number One in Full)
		NumberTwo EQU 0x25	;; TensTwo*10 (Number two without the
		
		FLAGS EQU 0X26 ;; FLAGS == 0->TensOne // ==1 -> UnitsOne .....
		TimerCounter EQU 0x27	;; Count Overflows
		
		RCV1 EQU 0x28	;; Recived Number #1
		RCV2 EQU 0X29	;; Recived Number #2
		
		Lsd EQU 0X30 	
		Msd EQU  0x31
		
		Ones EQU 0x32	;; Total Number of Ones in the Result
		Tens EQU 0x33	;; Total Number of Tens  in the Result
		Hunds EQU 0x34	;; Total Number of Hundreds in the Result
		Thous EQU 0x35	;; Total Number of Thousands in the Result
		
		Temp EQU 0x36	;; Temporary location used in multiplication
		Result EQU 0x37	;; Result of multiplication 
		NumHolder EQU 0x38	;; Un-used variable 
	
		outerCounter EQU 0x39 ; Define file registers for the counters
		innerCounter EQU 0x40
		counter EQU 0X41
		skipFlags EQU 0x42	;; Store if first iteration or Not
		;====================================================================
		; RESET and INTERRUPT VECTORS
		;====================================================================
		
		      ; Reset Vector
		RST   code  0x0 
		      goto  Start
		     
		ISR   code 0x04
		      NOP 
		;; ISR Idea: an interrupt is either caused by the button-click or the timeroverflow
		;; If the button is pressed, we will increment the correct number
		;; In order to keep track of which number to increment, we will use a variable FLAGS
		;; So and if else kind of clause can determine the number to be incremented at each click
		;; For timer interrupts, We are using Timer1 which overflows once every 0.5s 
		;; Thus if we count until 4 overflows, we can then increment FLAGS to change to the next number 
		;; -> Each button click resets the overflow count!   
		      BANKSEL PIR1
		      BTFSC PIR1, 0 
		      GOTO TimerInterrupt 
		   
		      BANKSEL PORTD
		      BSF PORTD, 0
		     MOVF FLAGS, W     
		     XORLW 0x00       
		     BTFSS STATUS, Z  
		     GOTO Test1
		     INCF TensOne,F 
		     MOVF TensOne, W
		     CALL  printNumberOne
		     MOVF TensOne,W
		     XORLW 0x0A ;; CHECK IF EQUAL TO 10 -> CHANGE TO 0 
		     BTFSS STATUS, Z
		     GOTO ifDone
		     CLRF TensOne
		     MOVF TensOne, W
		     CALL  printNumberOne
		     GOTO ifDone
		    
		    ; Check if REG == 1
		Test1     
		     MOVF FLAGS, W 
		     XORLW 0x01       
		     BTFSS STATUS, Z  
		     GOTO Test2
		     INCF UnitsOne,F 
		     CALL  printNumberOne
		     MOVF UnitsOne, W
		     XORLW 0x0A ;; CHECK IF EQUAL TO 10 -> CHANGE TO 0 
		     BTFSS STATUS, Z
		     GOTO ifDone
		     CLRF UnitsOne
		     CALL  printNumberOne
		     GOTO ifDone
		    
		    ; Check if REG == 2
		Test2
		    MOVF FLAGS, W  
		     XORLW 0x02
		     BTFSS STATUS, Z 
		     GOTO Test3
		     INCF TensTwo,F 
		     CALL printNumberTwo
		     MOVF TensTwo, W
		     XORLW 0x0A ;; CHECK IF EQUAL TO 10 -> CHANGE TO 0 
		     BTFSS STATUS, Z
		     GOTO ifDone
		     CLRF TensTwo
		      CALL printNumberTwo
		     GOTO ifDone
		    
		    ; Check if REG == 3
		Test3
		     MOVF FLAGS, W 
		     XORLW 0x03       
		     BTFSS STATUS, Z  
		     GOTO ifDone
		     INCF UnitsTwo,F    
		     MOVF UnitsTwo, W 
		     CALL printNumberTwo
		     MOVF TensTwo, W
		     XORLW 0x0A ;; CHECK IF EQUAL TO 10 -> CHANGE TO 0 
		     BTFSS STATUS, Z
		     GOTO ifDone
		     CLRF UnitsTwo
		     CALL printNumberTwo
		     MOVF UnitsTwo, W
		     
		ifDone
		      CLRF TimerCounter
		      BCF INTCON, 1 ; Clear the flag interrupt bit
		      GOTO endInt
		      
		TimerInterrupt 
		      BANKSEL PIR1
		      BCF PIR1, 0 
		
		      INCF TimerCounter, F ; inc and get 
		      MOVF TimerCounter, W
		      
		     
		      XORLW 0x05   
		      BTFSS STATUS, Z  
		      GOTO endInt
		      NOP
		      BANKSEL PORTD
		      INCF FLAGS, F
		      MOVF FLAGS, W 
		      
		      ;INCF PORTD, F
		      BSF PORTD,0
		     
		      CLRF TimerCounter
		
		      
		         
		endInt
		      NOP
		      BANKSEL TMR1H
		      CLRF TMR1H 
		      CLRF TMR1L
		      BANKSEL PORTB
		      movf PORTB, F	; Read PortB (to itself) to end mismatch condition
		      RETFIE     
		   
		
		INCLUDE "LCDIS_PORTD.INC" ;; include library for LCD
		;====================================================================
		; CODE SEGMENT
		;====================================================================
		
		PGM   code
		Start
		      
		      NOP
		      ;; Initializations Here: PORTD Output (LCD)
		      BANKSEL TRISD 
		      CLRF TRISD 
		      CLRF INTCON
		      
		      BANKSEL TRISC 
		      CLRF TRISC 	;; PortC Output (Communication)
		      
		      BANKSEL TRISB 
		      BSF TRISB, 0	;; Bit 0 of portb is input (Push Button)
		      
		      ; Enable Interrupts
		      BSF INTCON, GIE 
		      BSF INTCON, PEIE 
		     
		
		      
		      
		      BANKSEL T1CON		;; Enable Timer1 & It's interrupts
		      BSF T1CON, T1CKPS1
		      BSF T1CON, T1CKPS0  ; 1:8 prescaler -> 0.5 sec
		      
		      
		      BANKSEL PIE1
		      BSF PIE1, TMR1IE 
		      
		      BANKSEL PORTD
		      MOVLW 0x00
		      MOVWF PORTD
		      
				;; Clear All Registers
		      CLRF TensOne		
		      CLRF UnitsOne
		      CLRF TensTwo
		      CLRF UnitsTwo
		      CLRF NumberOne
		      CLRF NumberTwo
		      CLRF RCV1
		      CLRF RCV2
		      CLRF Lsd
		      CLRF Msd
		      CLRF Ones
		      CLRF Tens
		      CLRF Hunds
		      CLRF Thous
		      CLRF Temp
		      CLRF Result 
		      CLRF NumHolder
		      CLRF counter
		      CLRF FLAGS
		   
		      
		      
		      CALL xms
		      CALL xms
		      CALL inid
		    
		    
		    ;CLEAR THE FIRST LINE
		     CALL clearFirstLine
		     NOP
		     NOP
		     NOP
		      
				;; if not first iteration -> Skip (Welcome to Multiplication)
		      BTFSC skipFlags, 0
		      GOTO SKIP
		      CALL printMessage
		      CALL printMessage
		      CALL printMessage
		SKIP:      
		      NOP
		      CALL print1 ;; 2nd line 00 -> INTERRUPT & Change 
		      NOP
		      CALL xms
		      CALL printNumberOne
		      
		      
		      
		      BCF INTCON, INTF	;;enable button interrupts
		      BSF INTCON, INTE
		      
		
		      BANKSEL T1CON
		      BSF T1CON, TMR1ON ; Get Timer Started
		      
		      BANKSEL PORTD
		      
		Loop 
		      BTFSC FLAGS, 1 ; Bit 1 is set = FLAGS = 2/3 -> Break Out  b'0000_0010
		      GOTO Number2
		      GOTO Loop
		      
		      
		Number2      
		      CALL printNumberOne
		      NOP 
		      BANKSEL T1CON
		      BCF T1CON, TMR1ON ;; Disable timer & do LCD Work
		      
		      ;;;;;;;;;;;;;;;;;;;;;;;;
		      ;; LCD Work.
		      CALL SECONDNUM
		      CALL printNumberTwo
		
		      ; PUT 00
		      ;;;;;;;;;;;;;;;;;;;;;;;;
		        
		      ;; After finishing LCD Work, Re-enable Timer & Reset it and go again
		      NOP
		      BANKSEL T1CON
		      BSF T1CON, TMR1ON
		      BANKSEL TMR1H
		      CLRF TMR1H 
		      CLRF TMR1L
		     
		      BANKSEL PORTD
		Loop2  
		      BTFSC FLAGS, 2 ; Bit 3 is set = FLAGS = 4 or higher -> Break Out  
		      GOTO Communication
		      GOTO Loop2
		
		Communication
		      NOP 
		      BANKSEL T1CON
		      BCF T1CON, TMR1ON		;; No need for button or timer interrupts anymore
		      
		      BCF INTCON,INTE
		      
		      ; PRINT =
		      BANKSEL PORTD
		      BCF Select, RS
		      MOVLW	0xC0	; DDRAM address for the second line
		      CALL	send		; and send command
		      
		       ; Set the cursor to the second line, 5 position
		
		      BCF Select, RS        ; Command mode
		      MOVLW   0x14   
		      CALL    send         
		      MOVLW   0x14   
		      CALL    send  
		      MOVLW   0x14   
		      CALL    send 
		      MOVLW   0x14   
		      CALL    send 
		      MOVLW   0x14   
		      CALL    send 
		      
		      
		      BSF	Select,RS	; Select data mode
		      MOVLW '='
		      CALL send
		      
		      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		      ;;; START Sending DATA to co-processor ;;;;;;;;;;;;;;;;;;;;;;;;;;;
		      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		      ;;;; Multiply TensOne by 10 & Add UnitsOne to it , that will be our first number;;;;;;;
		      ;;;; We will send it and make sure that our MSB is set to 1 (0-99 Number can be reperesnted in 7 Bits thus the MSB is free-use)
		      ;;;; We will give a small delay for the co-proccessor to read the value then we will send the UnitsTwo Number Through (MSB = 1 Aswell)
		      ;;;; Then Do a quick multiplication & then switch PORTC to OUTPUTS VIA TRISC & LISTEN UNTIL THE BUS CHANGES. 
		      ;;;; Add Both Results then Send to LCD.	
		      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 00-99 -> 7 bits --- PORTC 8 bits -> PC7 will be used for Synchronization
		      
		      CLRW 
		      ADDWF TensOne, W
		      ADDWF TensOne, W
		      ADDWF TensOne, W
		      ADDWF TensOne, W
		      ADDWF TensOne, W
		      
		      ADDWF TensOne, W
		      ADDWF TensOne, W
		      ADDWF TensOne, W
		      ADDWF TensOne, W
		      ADDWF TensOne, W
		      
		      ADDWF UnitsOne, W ;; Number One now in W
		      
		      
		      MOVWF NumberOne
		      
		      MOVF NumberOne, W	;; Write to portc
		      MOVWF PORTC
		      
		      BSF PORTC, 7  ;; Set Last Bit to Notify co-processor ab number rcved
		      
		      NOP
		      NOP
		      NOP
		      NOP
		      NOP
		      
		      MOVF  UnitsTwo, W ;; send unit of number #2
		      MOVWF PORTC 
		      BCF PORTC, 7 
		      
		      NOP
		      NOP
		      NOP
		      NOP
		      NOP
		      NOP
		      NOP 		;;; Wait a bit then switch to input & wait for response
		      
		      BANKSEL TRISC
		      MOVLW 0XFF
		      MOVWF TRISC   ;; CHANGE PORT C TO INPUT!
		      
		  
		      
		      
		      BANKSEL PORTC	;; Next we will wait for result from Co-Processor
		      
		LoopRCV  
		      BTFSC PORTC, 7 ;; IF BIT 7 IS ON -> NUMBER IS RCVD 
		      GOTO RCVD
		      goto  LoopRCV      
		
		RCVD
		      MOVF PORTC, W       
		      MOVWF RCV1
		      BCF RCV1, 7
		            
		  
		LoopRCV2
		      BTFSS PORTC, 7
		      GOTO RCVD2
		      goto  LoopRCV2      
		
		RCVD2
		      MOVF PORTC, W       
		      MOVWF RCV2
		      ;;;; Communications Done. -> Do own multiplication & add both results 
		      
		    
		      CLRW 
		      ADDWF TensTwo, W
		      ADDWF TensTwo, W
		      ADDWF TensTwo, W
		      ADDWF TensTwo, W
		      ADDWF TensTwo, W
		      
		      ADDWF TensTwo, W
		      ADDWF TensTwo, W
		      ADDWF TensTwo, W
		      ADDWF TensTwo, W
		      ADDWF TensTwo, W
		      
		      MOVWF NumberTwo 
		      ;check if number two =0 -> END MUL & result = 0 
		      MOVF NumberTwo,W
		      BTFSC STATUS, Z
		      GOTO EndMul 
		      
		      
		      ;;; Multiplication Idea:
			  ;;; Keep on doing successive additions, on overflow, add 2 hundreds, 5 tens, 6 ones
		L1
		      MOVF Result, W
		      ADDWF NumberOne, W 
		      BTFSS STATUS, C
		      GOTO DontIncrement
		      INCF Hunds 
		      INCF Hunds
		      
		      INCF Tens
		      INCF Tens
		      INCF Tens
		      INCF Tens
		      INCF Tens
		      
		      INCF Ones
		      INCF Ones
		      INCF Ones
		      INCF Ones 
		      INCF Ones
		      INCF Ones
		DontIncrement
		
		      MOVWF Result ;;; store current multiplication result
		      DECF NumberTwo, F
		      MOVF NumberTwo, W
		      XORLW 0x00
		      BTFSC STATUS, Z
		      GOTO EndMul
		      GOTO L1
		      
		EndMul      
		      MOVF Result, W
		    
			;;; Split the number left in result to Hundreds, Tens & Ones
		; Calclulate hundreds......................................
		
				BSF		STATUS,C	; set carry for subtract
				MOVLW	D'100'		; load 100
		sub1		SUBWF	Result,1		; and subtract from result
				INCF	Hunds		; count number of loops
				BTFSC	STATUS,C	; and check if done
				GOTO	sub1		; no, carry on
		
				ADDWF	Result,1		; yes, add 100 back on
				DECF	Hunds		; and correct loop count
		
		; Calculate tens digit.....................................
		
				BSF		STATUS,C	; repeat process for tens
				MOVLW	D'10'		; load 10
		sub2		SUBWF	Result		; and subtract from result
				INCF	Tens		; count number of loops
				BTFSC	STATUS,C	; and check if done
				GOTO	sub2		; no, carry on
		
				ADDWF	Result		; yes, add 100 back on
				DECF	Tens		; and correct loop count
				MOVF	Result,W		; load remainder
				ADDWF	Ones,F		; and store as ones digit
		
				
				
		;;;;;;;;;;;;;;; NEXT USE RCV1, RCV2 -> Extract 10's & 1's from each and add to variables
		
			MOVF	RCV1,W	
			MOVWF	Lsd		; into low digit store
			CLRF	Msd		; high digit = 0
			BSF	STATUS,C	; set C flag
			MOVLW	D'10'		; load 10
		
		again	SUBWF	Lsd		; sub 10 from result
			INCF	Msd		; inc high digit
			BTFSC	STATUS,C	; check if negative
			GOTO	again		; no, keep going
			ADDWF	Lsd		; yes, add 10 back 
			DECF	Msd		; inc high digit
			
			MOVF Msd, W
			ADDWF Hunds, F
			MOVF Lsd, W
			ADDWF Tens, F
			MOVF RCV2, W
			ADDWF Ones, F
			
	;;; Next part is :
	;;; for each 10 in ones, we will increment tens
	;;; & for each 10 in tens, we will increment hundreds
	;;; & for each 10 in hundreds, we will increment thousands
	;;; This is done in order to make sure results are correct.
	;;; Idea: Subtract 10 & check carry bit -> if set then increment next digit
	;;; if not set number drops below 0, add back 10 & move to next digit
		OnesLoop
		    MOVLW   D'10'       
		    SUBWF   Ones,F     ; Subtract 10 from Ones
		    BTFSS   STATUS, C   ; If carry is SET => Ones is 0-9 => GOTO (Re-Add 10 & Exit)
		    GOTO    OnesLoop_Exit   
		    INCF    Tens
		    GOTO    OnesLoop    ; Go to Tens loop
		OnesLoop_Exit
		    MOVLW D'10'
		    ADDWF Ones, F
		
		TensLoop
		    MOVLW   D'10'     
		    SUBWF   Tens, F    
		    BTFSS   STATUS, C  
		    GOTO    TensLoop_Exit
		    INCF Hunds 
		    GOTO    TensLoop  
		TensLoop_Exit
		    MOVLW D'10'
		    ADDWF Tens, F
		    
		HundsLoop
		    MOVLW   D'10'     
		    SUBWF   Hunds, F    
		    BTFSS   STATUS, C  
		    GOTO    HundsLoop_Exit
		    INCF 	Thous 
		    GOTO    HundsLoop  
		HundsLoop_Exit
		    MOVLW D'10'
		    ADDWF Hunds, F  
		  
		
		  
		   CALL printResult
		
		    ; call function to display result
		    CALL DisplayResult
		    
		    BSF skipFlags, 0
		    
		restart:
		    BTFSS PORTB,0
		    GOTO Start
		    GOTO restart
		    
		          
		      
		      
		endLoop      
		       GOTO endLoop
		;====================================================================
		printMessage:
		   NOP
		   
		   BCF Select, RS
		   MOVLW	0x80	; DDRAM address for the first position of the first line
		   CALL	send	; and send command
		   
		   MOVLW 'W'
		   BSF Select, RS
		   CALL send
		   
		   
		      NOP
		   MOVLW 'E'
		   CALL send
		      NOP
		   MOVLW 'L'
		   CALL send
		      NOP
		   MOVLW 'C'
		   CALL send
		      NOP
		   MOVLW 'O'
		   call send
		      NOP
		   MOVLW 'M'
		   call send
		      NOP
		   MOVLW 'E'
		   call send
		      NOP
		   
		   
		   BCF Select, RS
		   MOVLW	0xC0	; DDRAM address for the second line
		   CALL	send		; and send command
		   
		   BSF Select, RS
		    MOVLW 'M'
		    call send
		       NOP
		    MOVLW 'U'
		    call send
		       NOP
		    MOVLW 'L'
		    call send
		       NOP
		    MOVLW 'T'
		    call send
		       NOP
		    MOVLW 'I'
		    call send
		       NOP
		    MOVLW 'P'
		    call send
		       NOP
		    MOVLW 'L'
		    call send
		       NOP
		    MOVLW 'I'
		    call send
		       NOP
		    MOVLW 'C'
		    call send
		       NOP
		    MOVLW 'A'
		    call send
		       NOP
		    MOVLW 'T'
		    call send
		       NOP
		    MOVLW 'I'
		    call send
		       NOP
		    MOVLW 'O'
		    call send
		       NOP
		    MOVLW 'N'
		    call send
		       NOP
		    
		    
		    CALL Delay1Sec
		    CALL Delay1Sec
		    CALL xms
		    CALL xms
		    call xms
		    
		  
		    
		    BCF Select, RS 
		    MOVLW	0x01		; Code to clear display
		    CALL	send		; and send code
		    
		    RETURN
		    
		;=====================================================================\
		Delay1Sec:;0.1 sec
		        MOVLW   D'250'       ; Outer loop counter 250 times
		        MOVWF   outerCounter ; Move to outer loop counter register
		
		    OuterLoop:
		        MOVLW   D'250'       ; Inner loop counter 250 times
		        MOVWF   innerCounter ; Move to inner loop counter register
		
		    InnerLoop:
		        DECFSZ  innerCounter, F ; Decrement inner loop counter
		        GOTO    InnerLoop       ; Continue inner loop if not zero
		
		        DECFSZ  outerCounter, F ; Decrement outer loop counter
		        GOTO    OuterLoop       ; Continue outer loop if not zero
		
		RETURN
		;=====================================================================
		print1:
		   NOP
		   NOP	
		;CLEAR THE FIRST LINE
		   CALL clearFirstLine
		   
		   BCF Select, RS
		   MOVLW	0x80	; DDRAM address for the first position of the first line
		   CALL	send	; and send command
		
		    BSF Select, RS
		    MOVLW 'N'
		    call send
		    
		    MOVLW 'U'
		    call send
		    
		    MOVLW 'M'
		    call send
		    
		    MOVLW 'B'
		    call send
		    
		   
		    MOVLW 'E'
		    call send
		    
		      
		    MOVLW 'R'
		    call send
		    
		      
		    MOVLW '1'
		    call send
		    
		    NOP
		    NOP
		    NOP
		
		
		RETURN   
		
		;=====================================================================
		printNumberOne
			 ;CALL clearSecondLine
			 ;NOP
			 ;; go to start of line 2
			BANKSEL PORTD
			BCF Select, RS
			MOVLW	0xC0
			CALL	send
			
			MOVF	TensOne,W		; load high digit result	
			ADDLW	030		; convert to ASCII
			BSF	Select,RS	; Select data mode
			CALL	send		; and send Msd
		
			MOVF	UnitsOne,W		; load low digit result
			ADDLW	030		; convert to ASCII
			BSF	Select,RS	; Select data mode
			CALL	send		; and send Msd
			
			BCF Select, RS
			 MOVLW	0x80	; DDRAM address for the first position of the first line
			 CALL	send	; and send command
		
		RETURN
		;=====================================================================
		 SECONDNUM
		 
		    BANKSEL PORTD
		    BCF Select, RS
		    MOVLW	0x80	; DDRAM address for the first position of the first line
		    CALL	send	; and send command
		   
		    BSF Select, RS
		    MOVLW 'N'
		    call send
		    
		    MOVLW 'U'
		    call send
		    
		    MOVLW 'M'
		    call send
		    
		    MOVLW 'B'
		    call send
		    
		   
		    MOVLW 'E'
		    call send
		    
		      
		    MOVLW 'R'
		    call send
		    
		      
		    MOVLW '2'
		    call send
		    
		    NOP
		    NOP
		    
		RETURN
		;==============================================================================
		printNumberTwo
		
		      BANKSEL PORTD
		      BCF Select, RS
		      MOVLW	0xC0	; DDRAM address for the second line
		      CALL	send		; and send command
		      
		       ;PRINT THE VALUE OF THE SECOND NUMBER
		       ; Set the cursor to the second line, fourth position
			 
		      BCF Select, RS        ; Command mode
		      MOVLW   0x14   
		      CALL    send         
		      MOVLW   0x14   
		      CALL    send  
		      BSF Select, RS   
		      MOVLW   'X' 
		      CALL    send 
		      
		      
			MOVF	TensTwo,W		; load high digit result	
			ADDLW	030		; convert to ASCII
			BSF	Select,RS	; Select data mode
			CALL	send		; and send Msd
		
			MOVF	UnitsTwo,W		; load low digit result
			ADDLW	030		; convert to ASCII
			BSF	Select,RS	; Select data mode
			CALL	send		; and send Msd
			
		      
		      
		       BANKSEL PORTD
		       BCF Select, RS
		       MOVLW	0x80	; DDRAM address for the first position of the first line
		       CALL	send	; and send command
		   
		      
		RETURN
		;===================================================================
		DisplayResult
		      BANKSEL PORTD
		      BCF Select, RS
		      MOVLW	0xC0	; DDRAM address for the second line
		      CALL	send		; and send command
		      
		       ;PRINT THE VALUE OF THE SECOND NUMBER
		       ; Set the cursor to the second line, fourth position
			 
		      BCF Select, RS        ; Command mode
		      MOVLW   0x14   
		      CALL    send         
		      MOVLW   0x14   
		      CALL    send  
		      MOVLW   0x14   
		      CALL    send  
		      MOVLW   0x14   
		      CALL    send  
		      MOVLW   0x14   
		      CALL    send  
		      MOVLW   0x14   
		      CALL    send  
		      
		      	BSF	Select,RS	; Select data mode
		        MOVF	Thous,W		; load high digit result	
			ADDLW	030		; convert to ASCII
			CALL	send		; and send Msd
			
			MOVF	Hunds,W		; load high digit result	
			ADDLW	030		; convert to ASCII
			CALL	send		; and send Msd
			
			MOVF	Tens,W		; load high digit result	
			ADDLW	030		; convert to ASCII
			CALL	send		; and send Msd
			
			
			MOVF	Ones,W		; load high digit result	
			ADDLW	030		; convert to ASCII
			CALL	send		; and send Msd
		      
		      
		      
		RETURN
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
		printResult
		   ; display the world 'result'
		    BCF Select, RS
		    MOVLW 0x80	; DDRAM address for the first position of the first line
		    CALL send	; and send command
		    BSF Select, RS
		    MOVLW 'R'
		    call send
		    MOVLW 'E'
		    call send
		    MOVLW 'S'
		    call send
		    MOVLW 'U'
		    call send
		    MOVLW 'L'
		    call send
		    MOVLW 'T'
		    call send
		    MOVLW ':'
		    CALL send
		    
		    NOP
		    NOP
		    NOP
		    NOP
		    NOP
		    
		
		RETURN
		;===================================================================
		; Clear the first line of the LCD
		clearFirstLine
		    BANKSEL PORTD
		    BCF Select, RS         ; Command mode
		    MOVLW   0x80           ; DDRAM address for the first position of the first line
		    CALL    send           ; Set cursor to the start of the first line
		    
		    BSF Select, RS         ; Data mode to write characters
		    MOVLW   16             ; Number of characters in the first line
		    MOVWF   counter        ; Initialize loop counter
		
		clearLoop:
		    MOVLW   ' '            ; ASCII code for space
		    CALL    send           ; Write space to current cursor position
		    DECFSZ  counter, F     ; Decrement counter and skip next line if zero
		    GOTO    clearLoop      ; Repeat until all positions are filled with spaces
		    NOP
		    NOP
		    NOP
		
		    RETURN
		 ;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>...   
		clearSecondLine
		      BANKSEL PORTD
		      BCF Select, RS
		      MOVLW	0xC0	; DDRAM address for the second line
		      CALL	send		; and send command
		      
		         BSF Select, RS         ; Data mode to write characters
		    MOVLW   16             ; Number of characters in the first line
		    MOVWF   counter        ; Initialize loop counter
		
		clearLoop2:
		    MOVLW   ' '            ; ASCII code for space
		    CALL    send           ; Write space to current cursor position
		    DECFSZ  counter, F     ; Decrement counter and skip next line if zero
		    GOTO    clearLoop2      ; Repeat until all positions are filled with spaces
		      
		
		RETURN
		;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>...
		END
		
