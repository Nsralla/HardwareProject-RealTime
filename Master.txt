;====================================================================
; Main.asm file generated by New Project wizard
;
; Created:   Thu Feb 1 2024
; Processor: PIC16F877A
; Compiler:  MPASM (Proteus)
;====================================================================

;====================================================================
; DEFINITIONS
;====================================================================

#include p16f877a.inc                ; Include register definition file

;====================================================================
; VARIABLES
;====================================================================
TensOne EQU 0X20 
UnitsOne EQU 0X21
TensTwo EQU 0x22
UnitsTwo EQU 0x23

NumberOne EQU 0x24
NumberTwo EQU 0x25

FLAGS EQU 0X26 ;; FLAGS == 0 -> TensOne, FLAGS == 1 DigitsOne (0-3)
TimerCounter EQU 0x27 			;; 2 sec -> Timer1 (0.5s) =. Count 4 times => Increment FLAGS

RCV1 EQU 0x28
RCV2 EQU 0X29

Lsd EQU 0X30
Msd EQU  0x31

Ones EQU 0x32
Tens EQU 0x33
Hunds EQU 0x34
Thous EQU 0x35

Temp EQU 0x36
Result EQU 0x37
NumHolder EQU 0x38
outerCounter EQU 0x39 ; Define file registers for the counters
innerCounter EQU 0x40
;====================================================================
; RESET and INTERRUPT VECTORS
;====================================================================

      ; Reset Vector
RST   code  0x0 
      goto  Start
     
ISR   code 0x04
      NOP 

      BANKSEL PIR1
      BTFSC PIR1, 0 
      GOTO TimerInterrupt 
   
      BANKSEL PORTD
      BSF PORTD, 0
     MOVF FLAGS, W     
     XORLW 0x00       
     BTFSS STATUS, Z  
     GOTO Test1
     INCF TensOne,F 
     MOVF TensOne, W
     CALL  printNumberOne
     MOVF TensOne,W
     XORLW 0x0A ;; CHECK IF EQUAL TO 10 -> CHANGE TO 0 
     BTFSS STATUS, Z
     GOTO ifDone
     CLRF TensOne
     MOVF TensOne, W
     CALL  printNumberOne
     GOTO ifDone
    
    ; Check if REG == 1
Test1     
     MOVF FLAGS, W 
     XORLW 0x01       
     BTFSS STATUS, Z  
     GOTO Test2
     INCF UnitsOne,F 
     CALL  printNumberOne
     MOVF UnitsOne, W
     XORLW 0x0A ;; CHECK IF EQUAL TO 10 -> CHANGE TO 0 
     BTFSS STATUS, Z
     GOTO ifDone
     CLRF UnitsOne
     CALL  printNumberOne
     GOTO ifDone
    
    ; Check if REG == 2
Test2
    MOVF FLAGS, W  
     XORLW 0x02
     BTFSS STATUS, Z 
     GOTO Test3
     INCF TensTwo,F 
     CALL printNumberTwo
     MOVF TensTwo, W
     XORLW 0x0A ;; CHECK IF EQUAL TO 10 -> CHANGE TO 0 
     BTFSS STATUS, Z
     GOTO ifDone
     CLRF TensTwo
      CALL printNumberTwo
     GOTO ifDone
    
    ; Check if REG == 3
Test3
     MOVF FLAGS, W 
     XORLW 0x03       
     BTFSS STATUS, Z  
     GOTO ifDone
     INCF UnitsTwo,F    
     MOVF UnitsTwo, W 
     CALL printNumberTwo
     MOVF TensTwo, W
     XORLW 0x0A ;; CHECK IF EQUAL TO 10 -> CHANGE TO 0 
     BTFSS STATUS, Z
     GOTO ifDone
     CLRF UnitsTwo
     CALL printNumberTwo
     MOVF UnitsTwo, W
     
ifDone
      CLRF TimerCounter
      BCF INTCON, 1 ; Clear the flag interrupt bit
      GOTO endInt
      
TimerInterrupt 
      BANKSEL PIR1
      BCF PIR1, 0 

      INCF TimerCounter, F ; inc and get 
      MOVF TimerCounter, W
      
     
      XORLW 0x05   
      BTFSS STATUS, Z  
      GOTO endInt
      NOP
      BANKSEL PORTD
      INCF FLAGS, F
      MOVF FLAGS, W 
      
      ;INCF PORTD, F
      BSF PORTD,0
     
      CLRF TimerCounter

      
         
endInt
      NOP
      BANKSEL TMR1H
      CLRF TMR1H 
      CLRF TMR1L
      BANKSEL PORTB
      movf PORTB, F	; Read PortB (to itself) to end mismatch condition
      RETFIE     
   

INCLUDE "LCDIS_PORTD.INC" 
;====================================================================
; CODE SEGMENT
;====================================================================

PGM   code
Start
      NOP
      ;; Initializations Here!
      BANKSEL TRISD 
      CLRF TRISD 
      
      BANKSEL TRISC 
      CLRF TRISC 
      
      BANKSEL TRISB 
      BSF TRISB, 0
      
      ; Enable Interrupts!
      BSF INTCON, GIE 
      BSF INTCON, PEIE 
     

      
      
      BANKSEL T1CON
      BSF T1CON, T1CKPS1
      BSF T1CON, T1CKPS0  ; 1:8 prescaler -> 0.5 sec
      
      
      BANKSEL PIE1
      BSF PIE1, TMR1IE 
      
      BANKSEL PORTD
      MOVLW 0x00
      MOVWF PORTD
      CLRF TensOne
      CLRF UnitsOne
      
      
      CALL xms
      CALL xms
      CALL inid
    
      ; Code Here!
      CALL printMessage
      CALL printMessage
      CALL printMessage
      
      CALL print1 ;; 2nd line 00 -> INTERRUPT & Change 
      
      CALL printNumberOne
      
      
      

      BSF INTCON, INTE
      

      BANKSEL T1CON
      BSF T1CON, TMR1ON ; Get Timer Started!
      
      BANKSEL PORTD
      
Loop 
      BTFSC FLAGS, 1 ; Bit 1 is set = FLAGS = 2/3 -> Break Out  b'0000_0010
      GOTO Number2
      GOTO Loop
      
      
Number2      
      CALL printNumberOne
      NOP 
      BANKSEL T1CON
      BCF T1CON, TMR1ON ;; Disable timer & do LCD Work
      
      ;;;;;;;;;;;;;;;;;;;;;;;;
      ;; LCD Work.
      CALL SECONDNUM
      CALL printNumberTwo

      ; PUT 00
      ;;;;;;;;;;;;;;;;;;;;;;;;
        
      ;; After finishing LCD Work, Re-enable Timer & Reset it and go again
      NOP
      BANKSEL T1CON
      BSF T1CON, TMR1ON
      BANKSEL TMR1H
      CLRF TMR1H 
      CLRF TMR1L
     
      BANKSEL PORTD
Loop2  
      BTFSC FLAGS, 2 ; Bit 3 is set = FLAGS = 4 or higher -> Break Out  
      GOTO Communication
      GOTO Loop2

Communication
      NOP 
      BANKSEL T1CON
      BCF T1CON, TMR1ON
      
      ; PRINT =
      BANKSEL PORTD
      BCF Select, RS
      MOVLW	0xC0	; DDRAM address for the second line
      CALL	send		; and send command
      
       ; Set the cursor to the second line, 5 position

      BCF Select, RS        ; Command mode
      MOVLW   0x14   
      CALL    send         
      MOVLW   0x14   
      CALL    send  
      MOVLW   0x14   
      CALL    send 
      MOVLW   0x14   
      CALL    send 
      MOVLW   0x14   
      CALL    send 
      
      
      BSF	Select,RS	; Select data mode
      MOVLW '='
      CALL send
      
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;; START Sending DATA to co-processor ;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;; Multiply TensOne by 10 & Add UnitsOne to it , that will be our first number;;;;;;;
      ;;;; We will send it and make sure that our MSB is set to 1 (0-99 Number can be reperesnted in 7 Bits thus the MSB is free-use)
      ;;;; We will give a small delay for the co-proccessor to read the value then we will send the UnitsTwo Number Through (MSB = 1 Aswell)
      ;;;; Then Do a quick multiplication & then switch PORTC to OUTPUTS VIA TRISC & LISTEN UNTIL THE BUS CHANGES. 
      ;;;; Add Both Results then Send to LCD.	
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 00-99 -> 7 bits --- PORTC 8 bits -> PC7 will be used for Synchronization
      
      CLRW 
      ADDWF TensOne, W
      ADDWF TensOne, W
      ADDWF TensOne, W
      ADDWF TensOne, W
      ADDWF TensOne, W
      
      ADDWF TensOne, W
      ADDWF TensOne, W
      ADDWF TensOne, W
      ADDWF TensOne, W
      ADDWF TensOne, W
      
      ADDWF UnitsOne, W ;; Number One now in W
      
      
      MOVWF NumberOne
      
      MOVF NumberOne, W
      MOVWF PORTC
      
      BSF PORTC, 7  ;; Set Last Bit to Notify co-processor ab number rcved
      
      NOP
      NOP
      NOP
      NOP
      NOP
      
      MOVF  UnitsTwo, W ;; send unit of number #2
      MOVWF PORTC 
      BCF PORTC, 7 
      
      NOP
      NOP
      NOP
      NOP
      NOP
      NOP
      NOP 		;;; Wait a bit then switch to input & wait for response
      
      BANKSEL TRISC
      MOVLW 0XFF
      MOVWF TRISC   ;; CHANGE PORT C TO INPUT!
      
  
      
      
      BANKSEL PORTC
      
LoopRCV  
      BTFSC PORTC, 7 ;; IF BIT 7 IS ON -> NUMBER IS RCVD 
      GOTO RCVD
      goto  LoopRCV      

RCVD
      MOVF PORTC, W       
      MOVWF RCV1
      BCF RCV1, 7
            
  
LoopRCV2
      BTFSS PORTC, 7
      GOTO RCVD2
      goto  LoopRCV2      

RCVD2
      MOVF PORTC, W       
      MOVWF RCV2
      ;;;; Communications Done. 
      ;;; NumHolder has Number1 , RCV1 (37) Has 2 MSD from co-pr RCV2 (5)has 1 LSD from co-pr  => We can extract 3 7 5 each into a register 
      ;;; NumHolder * 10*TensTwo => Thous Hunds Tens Ones
     
     
      CLRW 
      ADDWF TensTwo, W
      ADDWF TensTwo, W
      ADDWF TensTwo, W
      ADDWF TensTwo, W
      ADDWF TensTwo, W
      
      ADDWF TensTwo, W
      ADDWF TensTwo, W
      ADDWF TensTwo, W
      ADDWF TensTwo, W
      ADDWF TensTwo, W
      
      MOVWF NumberTwo 
      ;check if number two =0 ; END MUL
      MOVF NumberTwo,W
      BTFSC STATUS, Z
      GOTO EndMul 
      
      
      
L1
      MOVF Result, W
      ADDWF NumberOne, W ; 10 x 00(n2)
      BTFSS STATUS, C
      GOTO DontIncrement
      INCF Hunds 
      INCF Hunds
      
      INCF Tens
      INCF Tens
      INCF Tens
      INCF Tens
      INCF Tens
      
      INCF Ones
      INCF Ones
      INCF Ones
      INCF Ones 
      INCF Ones
      INCF Ones
DontIncrement

      MOVWF Result ;;; store current multiplication result
      DECF NumberTwo, F
      MOVF NumberTwo, W
      XORLW 0x00
      BTFSC STATUS, Z
      GOTO EndMul
      GOTO L1
      
EndMul      
      MOVF Result, W
    
; Calclulate hundreds......................................

		BSF		STATUS,C	; set carry for subtract
		MOVLW	D'100'		; load 100
sub1		SUBWF	Result,1		; and subtract from result
		INCF	Hunds		; count number of loops
		BTFSC	STATUS,C	; and check if done
		GOTO	sub1		; no, carry on

		ADDWF	Result,1		; yes, add 100 back on
		DECF	Hunds		; and correct loop count

; Calculate tens digit.....................................

		BSF		STATUS,C	; repeat process for tens
		MOVLW	D'10'		; load 10
sub2		SUBWF	Result		; and subtract from result
		INCF	Tens		; count number of loops
		BTFSC	STATUS,C	; and check if done
		GOTO	sub2		; no, carry on

		ADDWF	Result		; yes, add 100 back on
		DECF	Tens		; and correct loop count
		MOVF	Result,W		; load remainder
		ADDWF	Ones,F		; and store as ones digit

		
		
;;;;;;;;;;;;;;; NEXT USE RCV1, RCV2

	MOVF	RCV1,W	
	MOVWF	Lsd		; into low digit store
	CLRF	Msd		; high digit = 0
	BSF	STATUS,C	; set C flag
	MOVLW	D'10'		; load 10

again	SUBWF	Lsd		; sub 10 from result
	INCF	Msd		; inc high digit
	BTFSC	STATUS,C	; check if negative
	GOTO	again		; no, keep going
	ADDWF	Lsd		; yes, add 10 back 
	DECF	Msd		; inc high digit
	
	MOVF Msd, W
	ADDWF Hunds, F
	MOVF Lsd, W
	ADDWF Tens, F
	MOVF RCV2, W
	ADDWF Ones, F
	
OnesLoop
    MOVLW   D'10'       
    SUBWF   Ones,F     ; Subtract 10 from Ones
    BTFSS   STATUS, C   ; If carry is SET => Ones is 0-9 => GOTO (Re-Add 10 & Exit)
    GOTO    OnesLoop_Exit   
    INCF    Tens
    GOTO    OnesLoop    ; Go to Tens loop
OnesLoop_Exit
    MOVLW D'10'
    ADDWF Ones, F

TensLoop
    MOVLW   D'10'     
    SUBWF   Tens, F    
    BTFSS   STATUS, C  
    GOTO    TensLoop_Exit
    INCF Hunds 
    GOTO    TensLoop  
TensLoop_Exit
    MOVLW D'10'
    ADDWF Tens, F
    
HundsLoop
    MOVLW   D'10'     
    SUBWF   Hunds, F    
    BTFSS   STATUS, C  
    GOTO    HundsLoop_Exit
    INCF 	Thous 
    GOTO    HundsLoop  
HundsLoop_Exit
    MOVLW D'10'
    ADDWF Hunds, F  
  


    ; call function to display result
    CALL DisplayResult
          
      
      
endLoop      
       GOTO endLoop
;====================================================================

printMessage:
   MOVLW 'W'
   BSF Select, RS
   CALL send
   MOVLW 'E'
   CALL send
   MOVLW 'L'
   CALL send
   MOVLW 'C'
   CALL send
   MOVLW 'O'
   call send
   MOVLW 'M'
   call send
   MOVLW 'E'
   call send
   
   
   BCF Select, RS
   MOVLW	0xC0	; DDRAM address for the second line
   CALL	send		; and send command
   
   BSF Select, RS
    MOVLW 'M'
    call send
    MOVLW 'U'
    call send
    MOVLW 'L'
    call send
    MOVLW 'T'
    call send
    MOVLW 'I'
    call send
    MOVLW 'P'
    call send
    MOVLW 'L'
    call send
    MOVLW 'I'
    call send
    MOVLW 'C'
    call send
    MOVLW 'A'
    call send
    MOVLW 'T'
    call send
    MOVLW 'I'
    call send
    MOVLW 'O'
    call send
    MOVLW 'N'
    call send
    
    
    CALL Delay1Sec
  
    
    BCF Select, RS 
    MOVLW	0x01		; Code to clear display
    CALL	send		; and send code
    
    RETURN
    
;=====================================================================\
Delay1Sec:
        MOVLW   D'250'       ; Outer loop counter 250 times
        MOVWF   outerCounter ; Move to outer loop counter register

    OuterLoop:
        MOVLW   D'250'       ; Inner loop counter 250 times
        MOVWF   innerCounter ; Move to inner loop counter register

    InnerLoop:
        DECFSZ  innerCounter, F ; Decrement inner loop counter
        GOTO    InnerLoop       ; Continue inner loop if not zero

        DECFSZ  outerCounter, F ; Decrement outer loop counter
        GOTO    OuterLoop       ; Continue outer loop if not zero

RETURN
;=====================================================================
print1:
   BCF Select, RS
   MOVLW	0x80	; DDRAM address for the first position of the first line
   CALL	send	; and send command

    BSF Select, RS
    MOVLW 'N'
    call send
    
    MOVLW 'U'
    call send
    
    MOVLW 'M'
    call send
    
    MOVLW 'B'
    call send
    
   
    MOVLW 'E'
    call send
    
      
    MOVLW 'R'
    call send
    
      
    MOVLW '1'
    call send


RETURN   

;=====================================================================
printNumberOne
	 ;; go to start of line 2
	 BANKSEL PORTD
	BCF Select, RS
	MOVLW	0xC0
	CALL	send
	
	MOVF	TensOne,W		; load high digit result	
	ADDLW	030		; convert to ASCII
	BSF	Select,RS	; Select data mode
	CALL	send		; and send Msd

	MOVF	UnitsOne,W		; load low digit result
	ADDLW	030		; convert to ASCII
	BSF	Select,RS	; Select data mode
	CALL	send		; and send Msd
	
	BCF Select, RS
	 MOVLW	0x80	; DDRAM address for the first position of the first line
	 CALL	send	; and send command

RETURN
;=====================================================================
 SECONDNUM
    BANKSEL PORTD
    BCF Select, RS
    MOVLW	0x80	; DDRAM address for the first position of the first line
    CALL	send	; and send command
   
    BSF Select, RS
    MOVLW 'N'
    call send
    
    MOVLW 'U'
    call send
    
    MOVLW 'M'
    call send
    
    MOVLW 'B'
    call send
    
   
    MOVLW 'E'
    call send
    
      
    MOVLW 'R'
    call send
    
      
    MOVLW '2'
    call send
    
    NOP
    NOP
    
RETURN
;==============================================================================
printNumberTwo

      BANKSEL PORTD
      BCF Select, RS
      MOVLW	0xC0	; DDRAM address for the second line
      CALL	send		; and send command
      
       ;PRINT THE VALUE OF THE SECOND NUMBER
       ; Set the cursor to the second line, fourth position
	 
      BCF Select, RS        ; Command mode
      MOVLW   0x14   
      CALL    send         
      MOVLW   0x14   
      CALL    send  
      BSF Select, RS   
      MOVLW   'X' 
      CALL    send 
      
      
	MOVF	TensTwo,W		; load high digit result	
	ADDLW	030		; convert to ASCII
	BSF	Select,RS	; Select data mode
	CALL	send		; and send Msd

	MOVF	UnitsTwo,W		; load low digit result
	ADDLW	030		; convert to ASCII
	BSF	Select,RS	; Select data mode
	CALL	send		; and send Msd
	
      
      
       BANKSEL PORTD
       BCF Select, RS
       MOVLW	0x80	; DDRAM address for the first position of the first line
       CALL	send	; and send command
   
      
RETURN
;===================================================================
DisplayResult
  BANKSEL PORTD
      BCF Select, RS
      MOVLW	0xC0	; DDRAM address for the second line
      CALL	send		; and send command
      
       ;PRINT THE VALUE OF THE SECOND NUMBER
       ; Set the cursor to the second line, fourth position
	 
      BCF Select, RS        ; Command mode
      MOVLW   0x14   
      CALL    send         
      MOVLW   0x14   
      CALL    send  
      MOVLW   0x14   
      CALL    send  
      MOVLW   0x14   
      CALL    send  
      MOVLW   0x14   
      CALL    send  
      MOVLW   0x14   
      CALL    send  
      
      	BSF	Select,RS	; Select data mode
        MOVF	Thous,W		; load high digit result	
	ADDLW	030		; convert to ASCII
	CALL	send		; and send Msd
	
	MOVF	Hunds,W		; load high digit result	
	ADDLW	030		; convert to ASCII
	CALL	send		; and send Msd
	
	MOVF	Tens,W		; load high digit result	
	ADDLW	030		; convert to ASCII
	CALL	send		; and send Msd
	
	
	MOVF	Ones,W		; load high digit result	
	ADDLW	030		; convert to ASCII
	CALL	send		; and send Msd
      
      
      
RETURN
;===================================================================
END
